{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "bb28e271",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2022 NVIDIA Corporation. All Rights Reserved.\n",
    "#\n",
    "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
    "# you may not use this file except in compliance with the License.\n",
    "# You may obtain a copy of the License at\n",
    "#\n",
    "#     http://www.apache.org/licenses/LICENSE-2.0\n",
    "#\n",
    "# Unless required by applicable law or agreed to in writing, software\n",
    "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
    "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
    "# See the License for the specific language governing permissions and\n",
    "# limitations under the License.\n",
    "# =============================================================================="
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77464844",
   "metadata": {},
   "source": [
    "<img src=\"http://developer.download.nvidia.com/compute/machine-learning/frameworks/nvidia_logo.png\" style=\"width: 90px; float: right;\">\n",
    "\n",
    "# Advanced NVTabular workflow\n",
    "\n",
    "This notebook is created using the latest stable [merlin-tensorflow](https://catalog.ngc.nvidia.com/orgs/nvidia/teams/merlin/containers/merlin-tensorflow/tags) container. \n",
    "\n",
    "## Overview\n",
    "\n",
    "This notebook builds on what is covered in [01-Getting-started NB](01-Getting-started.ipynb). In this notebook we will take a closer look at running more complex `Operators`.\n",
    "\n",
    "We will also examine the functionality of the `Schema` -- this can be very useful for learning more about our data and instructing which columns we would like to use and how.\n",
    "\n",
    "\n",
    "### Learning objectives\n",
    "\n",
    "- Leveraging more complex Merlin NVTabular Operators\n",
    "- Splitting our data in chunks to limit memory footprint\n",
    "- Understanding the role of the schema and modifying it"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c5598ae",
   "metadata": {},
   "source": [
    "## Downloading the dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "60653f70",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-09-13 07:41:27.850043: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-09-13 07:41:27.850489: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-09-13 07:41:27.850632: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "/usr/local/lib/python3.8/dist-packages/cudf/core/frame.py:384: UserWarning: The deep parameter is ignored and is only included for pandas compatibility.\n",
      "  warnings.warn(\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "from merlin.datasets.entertainment import get_movielens\n",
    "\n",
    "input_path = os.environ.get(\"INPUT_DATA_DIR\", os.path.expanduser(\"~/merlin-framework/movielens/\"))\n",
    "get_movielens(variant=\"ml-1m\", path=input_path); #noqa"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "412d4c12",
   "metadata": {},
   "source": [
    "## Reading in the data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f775d893",
   "metadata": {},
   "outputs": [],
   "source": [
    "from merlin.core.dispatch import get_lib\n",
    "\n",
    "data = get_lib().read_parquet(f'{input_path}ml-1m/train.parquet').sample(frac=1)\n",
    "\n",
    "train = data.iloc[:600_000]\n",
    "valid = data.iloc[600_000:]\n",
    "\n",
    "movies = get_lib().read_parquet(f'{input_path}ml-1m/movies_converted.parquet')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1b83f0f2",
   "metadata": {},
   "source": [
    "From the provided `train` and `validation` sets we extract `userId`, `movieId` and `rating`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "bdf108aa",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>userId</th>\n",
       "      <th>movieId</th>\n",
       "      <th>rating</th>\n",
       "      <th>timestamp</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>315038</th>\n",
       "      <td>1880</td>\n",
       "      <td>1674</td>\n",
       "      <td>3</td>\n",
       "      <td>975379394</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>835377</th>\n",
       "      <td>5021</td>\n",
       "      <td>3468</td>\n",
       "      <td>4</td>\n",
       "      <td>962583655</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>105787</th>\n",
       "      <td>699</td>\n",
       "      <td>2205</td>\n",
       "      <td>2</td>\n",
       "      <td>986531971</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150012</th>\n",
       "      <td>966</td>\n",
       "      <td>1653</td>\n",
       "      <td>1</td>\n",
       "      <td>975115827</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>137192</th>\n",
       "      <td>883</td>\n",
       "      <td>3911</td>\n",
       "      <td>4</td>\n",
       "      <td>975260600</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "        userId  movieId  rating  timestamp\n",
       "315038    1880     1674       3  975379394\n",
       "835377    5021     3468       4  962583655\n",
       "105787     699     2205       2  986531971\n",
       "150012     966     1653       1  975115827\n",
       "137192     883     3911       4  975260600"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "42ffafa0",
   "metadata": {},
   "source": [
    "We will also use the metadata contained in `movies`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "86a8d694",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>movieId</th>\n",
       "      <th>title</th>\n",
       "      <th>genres</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1</td>\n",
       "      <td>Toy Story (1995)</td>\n",
       "      <td>[Animation, Children's, Comedy]</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2</td>\n",
       "      <td>Jumanji (1995)</td>\n",
       "      <td>[Adventure, Children's, Fantasy]</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>3</td>\n",
       "      <td>Grumpier Old Men (1995)</td>\n",
       "      <td>[Comedy, Romance]</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>4</td>\n",
       "      <td>Waiting to Exhale (1995)</td>\n",
       "      <td>[Comedy, Drama]</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>5</td>\n",
       "      <td>Father of the Bride Part II (1995)</td>\n",
       "      <td>[Comedy]</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   movieId                               title  \\\n",
       "0        1                    Toy Story (1995)   \n",
       "1        2                      Jumanji (1995)   \n",
       "2        3             Grumpier Old Men (1995)   \n",
       "3        4            Waiting to Exhale (1995)   \n",
       "4        5  Father of the Bride Part II (1995)   \n",
       "\n",
       "                             genres  \n",
       "0   [Animation, Children's, Comedy]  \n",
       "1  [Adventure, Children's, Fantasy]  \n",
       "2                 [Comedy, Romance]  \n",
       "3                   [Comedy, Drama]  \n",
       "4                          [Comedy]  "
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "movies.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d75cb24",
   "metadata": {},
   "source": [
    "Let's create `Merlin Dataset`s that we will be able to run through our workflow (a workflow defines the operations we would like performed on our data)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "d0f72d61",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<merlin.io.dataset.Dataset at 0x7f1c2628e550>,\n",
       " <merlin.io.dataset.Dataset at 0x7f1c2628e0a0>)"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import nvtabular as nvt\n",
    "from merlin.schema.tags import Tags\n",
    "\n",
    "train_ds = nvt.Dataset(train, npartitions=2)\n",
    "valid_ds = nvt.Dataset(valid)\n",
    "\n",
    "train_ds, valid_ds"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ecf6eda0",
   "metadata": {},
   "source": [
    "The constructor `nvt.Dataset(...)` accepts an important parameter: `npartitions`. We can leverage it to specify into how many chunks we would like our data to be split. Our workflow will process data in chunks and by increasing the number of partitions we can limit the memory footprint.\n",
    "\n",
    "We have to remember though to shuffle the data so that all relevant records reside in a single partition. Otherwise, depending on the operations we chose to perform, the results of our workflow might be incorrect."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b09971ea",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<merlin.io.dataset.Dataset at 0x7f1c26296790>"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_ds.shuffle_by_keys('userId')\n",
    "valid_ds.shuffle_by_keys('userId')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "298ee6fb",
   "metadata": {},
   "source": [
    "We have now shuffled the records so that all examples for the same `userId` reside in the same partition.\n",
    "\n",
    "The number of partitions hasn't changed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "86d80fb7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_ds.npartitions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ee5c7c2",
   "metadata": {},
   "source": [
    "## Defining the workflow"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad73fc70",
   "metadata": {},
   "source": [
    "### Joining an external dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f849efd",
   "metadata": {},
   "source": [
    "We want to make use of information contained in the `movies` DataFrame.\n",
    "\n",
    "Let us join it onto our data, making sure we only select the `genres` column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4f5ad3a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "genres = ['movieId'] >> nvt.ops.JoinExternal(movies, on='movieId', columns_ext=['movieId', 'genres'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0956648e",
   "metadata": {},
   "source": [
    "The `genres` information is represented as a list of strings. In order for us to be able to use it for training an ML model we need to encode the strings as categories."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "174360dc",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0     [Animation, Children's, Comedy]\n",
       "1    [Adventure, Children's, Fantasy]\n",
       "2                   [Comedy, Romance]\n",
       "3                     [Comedy, Drama]\n",
       "4                            [Comedy]\n",
       "Name: genres, dtype: list"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "movies['genres'].head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0242c3a0",
   "metadata": {},
   "source": [
    "### Encoding a list of strings as categories"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "70ab23a9",
   "metadata": {},
   "source": [
    "We leverage the `Categorify` operator to encode our lists of strings.\n",
    "\n",
    "Additionally, let's treat the categories that appear infrequently as unknowns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "45562fe9",
   "metadata": {},
   "outputs": [],
   "source": [
    "genres = genres >> nvt.ops.Categorify(freq_threshold=10)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc1004cf",
   "metadata": {},
   "source": [
    "### Running a custom preprocessing step"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fdf87e58",
   "metadata": {},
   "source": [
    "Let's look at an example of how we can run a custom preprocessing step on our data.\n",
    "\n",
    "Here we will define our own function that will transform the `rating` column to `binary_rating`. We will output a value of False for any `rating` below 4 and a value of True for any rating of `4` or `5`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "20fd4f8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def rating_to_binary(col):\n",
    "    return col > 3"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7bf46a55",
   "metadata": {},
   "source": [
    "The `LambdaOp` is an operator that takes in a function and performs a rowwise transformation.\n",
    "\n",
    "Here, `LambdaOp` takes in the `rating_to_binary` function and will apply it to the values in the `rating` column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "96b2806d",
   "metadata": {},
   "outputs": [],
   "source": [
    "binary_rating = ['rating'] >> nvt.ops.LambdaOp(rating_to_binary) >> nvt.ops.Rename(name='binary_rating')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "666439ad",
   "metadata": {},
   "source": [
    "### Tagging columns"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "357ca53e",
   "metadata": {},
   "source": [
    "Let us also tag our columns. This will help streamline model training and serving down the road, should we opt to do so using other components of the Merlin Framework.\n",
    "\n",
    "Running NVTabular operators on our data automatically tags the output columns. For instance, the `Categorify` operator we used above will tag the output columns as `Tags.CATEGORICAL`. Still, some information that can be useful down the road needs to be added by hand. This is true for instance for target information. Let's add this information below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "0748ac37",
   "metadata": {},
   "outputs": [],
   "source": [
    "userId = ['userId'] >> nvt.ops.Categorify() >> nvt.ops.AddTags(tags=[Tags.USER_ID, Tags.CATEGORICAL, Tags.USER])\n",
    "movieId = ['movieId'] >> nvt.ops.Categorify() >> nvt.ops.AddTags(tags=[Tags.ITEM_ID, Tags.CATEGORICAL, Tags.ITEM])\n",
    "binary_rating = binary_rating >> nvt.ops.AddTags(tags=[Tags.TARGET, Tags.BINARY_CLASSIFICATION])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f3ce8958",
   "metadata": {},
   "source": [
    "## Applying the workflow to the train and validation sets"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0790675d",
   "metadata": {},
   "source": [
    "We are now ready to create our workflow."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "6b7226fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "workflow = nvt.Workflow(userId + movieId + genres + binary_rating)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "754ac346",
   "metadata": {},
   "source": [
    "Let us now fit the `workflow` to our train set and transform the train and validation sets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "4aef5e8a",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.8/dist-packages/cudf/core/frame.py:384: UserWarning: The deep parameter is ignored and is only included for pandas compatibility.\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>userId</th>\n",
       "      <th>movieId</th>\n",
       "      <th>genres</th>\n",
       "      <th>binary_rating</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>112</td>\n",
       "      <td>1326</td>\n",
       "      <td>[1]</td>\n",
       "      <td>True</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>251</td>\n",
       "      <td>1508</td>\n",
       "      <td>[1]</td>\n",
       "      <td>True</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>147</td>\n",
       "      <td>254</td>\n",
       "      <td>[7, 1]</td>\n",
       "      <td>True</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2555</td>\n",
       "      <td>238</td>\n",
       "      <td>[1]</td>\n",
       "      <td>True</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>566</td>\n",
       "      <td>1000</td>\n",
       "      <td>[3, 8, 4]</td>\n",
       "      <td>False</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   userId  movieId     genres  binary_rating\n",
       "0     112     1326        [1]           True\n",
       "1     251     1508        [1]           True\n",
       "2     147      254     [7, 1]           True\n",
       "3    2555      238        [1]           True\n",
       "4     566     1000  [3, 8, 4]          False"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_transformed = workflow.fit_transform(train_ds)\n",
    "valid_transformed = workflow.transform(valid_ds)\n",
    "valid_transformed.compute().head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0bd00418",
   "metadata": {},
   "source": [
    "Our data was processed as we expected.\n",
    "\n",
    "Let us look at the schema."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "778956ee",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>name</th>\n",
       "      <th>tags</th>\n",
       "      <th>dtype</th>\n",
       "      <th>is_list</th>\n",
       "      <th>is_ragged</th>\n",
       "      <th>properties.num_buckets</th>\n",
       "      <th>properties.freq_threshold</th>\n",
       "      <th>properties.max_size</th>\n",
       "      <th>properties.start_index</th>\n",
       "      <th>properties.cat_path</th>\n",
       "      <th>properties.domain.min</th>\n",
       "      <th>properties.domain.max</th>\n",
       "      <th>properties.domain.name</th>\n",
       "      <th>properties.embedding_sizes.cardinality</th>\n",
       "      <th>properties.embedding_sizes.dimension</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>userId</td>\n",
       "      <td>(Tags.USER, Tags.CATEGORICAL, Tags.USER_ID)</td>\n",
       "      <td>int64</td>\n",
       "      <td>False</td>\n",
       "      <td>False</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>.//categories/unique.userId.parquet</td>\n",
       "      <td>0.0</td>\n",
       "      <td>6041.0</td>\n",
       "      <td>userId</td>\n",
       "      <td>6041.0</td>\n",
       "      <td>210.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>movieId</td>\n",
       "      <td>(Tags.ITEM_ID, Tags.ITEM, Tags.CATEGORICAL)</td>\n",
       "      <td>int64</td>\n",
       "      <td>False</td>\n",
       "      <td>False</td>\n",
       "      <td>NaN</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>.//categories/unique.movieId.parquet</td>\n",
       "      <td>0.0</td>\n",
       "      <td>1852.0</td>\n",
       "      <td>movieId</td>\n",
       "      <td>1852.0</td>\n",
       "      <td>108.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>genres</td>\n",
       "      <td>(Tags.CATEGORICAL)</td>\n",
       "      <td>int64</td>\n",
       "      <td>True</td>\n",
       "      <td>True</td>\n",
       "      <td>NaN</td>\n",
       "      <td>100.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>.//categories/unique.genres.parquet</td>\n",
       "      <td>0.0</td>\n",
       "      <td>19.0</td>\n",
       "      <td>genres</td>\n",
       "      <td>19.0</td>\n",
       "      <td>16.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>binary_rating</td>\n",
       "      <td>(Tags.BINARY_CLASSIFICATION, Tags.TARGET)</td>\n",
       "      <td>bool</td>\n",
       "      <td>False</td>\n",
       "      <td>False</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "[{'name': 'userId', 'tags': {<Tags.USER: 'user'>, <Tags.CATEGORICAL: 'categorical'>, <Tags.USER_ID: 'user_id'>}, 'properties': {'num_buckets': None, 'freq_threshold': 0, 'max_size': 0, 'start_index': 0, 'cat_path': './/categories/unique.userId.parquet', 'domain': {'min': 0, 'max': 6041, 'name': 'userId'}, 'embedding_sizes': {'cardinality': 6041, 'dimension': 210}}, 'dtype': dtype('int64'), 'is_list': False, 'is_ragged': False}, {'name': 'movieId', 'tags': {<Tags.ITEM_ID: 'item_id'>, <Tags.ITEM: 'item'>, <Tags.CATEGORICAL: 'categorical'>}, 'properties': {'num_buckets': None, 'freq_threshold': 0, 'max_size': 0, 'start_index': 0, 'cat_path': './/categories/unique.movieId.parquet', 'domain': {'min': 0, 'max': 1852, 'name': 'movieId'}, 'embedding_sizes': {'cardinality': 1852, 'dimension': 108}}, 'dtype': dtype('int64'), 'is_list': False, 'is_ragged': False}, {'name': 'genres', 'tags': {<Tags.CATEGORICAL: 'categorical'>}, 'properties': {'num_buckets': None, 'freq_threshold': 100, 'max_size': 0, 'start_index': 0, 'cat_path': './/categories/unique.genres.parquet', 'domain': {'min': 0, 'max': 19, 'name': 'genres'}, 'embedding_sizes': {'cardinality': 19, 'dimension': 16}}, 'dtype': dtype('int64'), 'is_list': True, 'is_ragged': True}, {'name': 'binary_rating', 'tags': {<Tags.BINARY_CLASSIFICATION: 'binary_classification'>, <Tags.TARGET: 'target'>}, 'properties': {}, 'dtype': dtype('bool'), 'is_list': False, 'is_ragged': False}]"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_transformed.schema"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48029e4b",
   "metadata": {},
   "source": [
    "The schema contains a lot of useful information, such as the frequency threshold that was used to process a column or its cardinality.\n",
    "\n",
    "Beyond providing us with useful information, schema can be used to inform other components of the Merlin Framework on what information from our datasets we would like it to act on and in what way.\n",
    "\n",
    "This is what the `Tags.TARGET`, `Tags.ITEM_ID`, and `Tags.USER_ID` achieve. When we train our Deep Leranin, the model will be able to infer which columns it should use as a source of what type of information.\n",
    "\n",
    "We can also use the schema to remove information that we wouldn't want our model to use in training.\n",
    "\n",
    "Let us look at an example of that below."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "18f16be0",
   "metadata": {},
   "source": [
    "## Training a DLRM Model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2f84cec3",
   "metadata": {},
   "source": [
    "Let us train a DLRM Model.\n",
    "\n",
    "It is usually advantageous to train on the entiriety of the available data. Let us do so below -- we will utilize all the columns included in our schema file.\n",
    "\n",
    "We tell the model about the structure of our data by passing in the `Schema` (`train_transformed.schema` in the example below)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "6fafc27b",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-08-24 23:45:16.972498: I tensorflow/core/platform/cpu_feature_guard.cc:194] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  SSE3 SSE4.1 SSE4.2 AVX\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n",
      "2022-08-24 23:45:16.973379: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.973563: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.973699: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.973972: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.974118: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.974257: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:991] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-08-24 23:45:16.974377: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1532] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 24576 MB memory:  -> device: 0, name: Quadro RTX 8000, pci bus id: 0000:08:00.0, compute capability: 7.5\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/5\n",
      "782/782 [==============================] - 14s 13ms/step - loss: 0.5644 - precision: 0.7184 - recall: 0.8133 - binary_accuracy: 0.7092 - auc: 0.7688 - regularization_loss: 0.0000e+00 - val_loss: 0.5397 - val_precision: 0.7416 - val_recall: 0.8116 - val_binary_accuracy: 0.7290 - val_auc: 0.7955 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 2/5\n",
      "782/782 [==============================] - 9s 11ms/step - loss: 0.5418 - precision: 0.7363 - recall: 0.8131 - binary_accuracy: 0.7250 - auc: 0.7907 - regularization_loss: 0.0000e+00 - val_loss: 0.5288 - val_precision: 0.7366 - val_recall: 0.8376 - val_binary_accuracy: 0.7343 - val_auc: 0.8043 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 3/5\n",
      "782/782 [==============================] - 10s 12ms/step - loss: 0.5331 - precision: 0.7403 - recall: 0.8172 - binary_accuracy: 0.7299 - auc: 0.7984 - regularization_loss: 0.0000e+00 - val_loss: 0.5184 - val_precision: 0.7562 - val_recall: 0.8081 - val_binary_accuracy: 0.7398 - val_auc: 0.8119 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 4/5\n",
      "782/782 [==============================] - 9s 12ms/step - loss: 0.5248 - precision: 0.7453 - recall: 0.8207 - binary_accuracy: 0.7355 - auc: 0.8058 - regularization_loss: 0.0000e+00 - val_loss: 0.5080 - val_precision: 0.7599 - val_recall: 0.8182 - val_binary_accuracy: 0.7468 - val_auc: 0.8203 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 5/5\n",
      "782/782 [==============================] - 9s 12ms/step - loss: 0.5162 - precision: 0.7519 - recall: 0.8204 - binary_accuracy: 0.7410 - auc: 0.8133 - regularization_loss: 0.0000e+00 - val_loss: 0.4997 - val_precision: 0.7601 - val_recall: 0.8349 - val_binary_accuracy: 0.7534 - val_auc: 0.8287 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 1/3\n",
      "782/782 [==============================] - 10s 12ms/step - loss: 0.4921 - precision: 0.7671 - recall: 0.8265 - binary_accuracy: 0.7558 - auc: 0.8325 - regularization_loss: 0.0000e+00 - val_loss: 0.4798 - val_precision: 0.7747 - val_recall: 0.8338 - val_binary_accuracy: 0.7649 - val_auc: 0.8422 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 2/3\n",
      "782/782 [==============================] - 10s 12ms/step - loss: 0.4815 - precision: 0.7739 - recall: 0.8304 - binary_accuracy: 0.7628 - auc: 0.8406 - regularization_loss: 0.0000e+00 - val_loss: 0.4685 - val_precision: 0.7804 - val_recall: 0.8411 - val_binary_accuracy: 0.7725 - val_auc: 0.8505 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 3/3\n",
      "782/782 [==============================] - 10s 12ms/step - loss: 0.4717 - precision: 0.7797 - recall: 0.8349 - binary_accuracy: 0.7694 - auc: 0.8478 - regularization_loss: 0.0000e+00 - val_loss: 0.4578 - val_precision: 0.7901 - val_recall: 0.8385 - val_binary_accuracy: 0.7790 - val_auc: 0.8580 - val_regularization_loss: 0.0000e+00\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<keras.callbacks.History at 0x7f1c021e8b80>"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import tensorflow\n",
    "import merlin.models.tf as mm\n",
    "\n",
    "model = mm.DLRMModel(\n",
    "    train_transformed.schema,\n",
    "    embedding_dim=64,\n",
    "    bottom_block=mm.MLPBlock([128, 64]),\n",
    "    top_block=mm.MLPBlock([128, 64, 32]),\n",
    "    prediction_tasks=mm.BinaryClassificationTask('rating_binary')\n",
    ")\n",
    "\n",
    "opt = tensorflow.optimizers.Adam(learning_rate=5e-3)\n",
    "model.compile(optimizer=opt)\n",
    "model.fit(train_transformed, validation_data=valid_transformed, batch_size=1024, epochs=5)\n",
    "\n",
    "model.optimizer.learning_rate = 1e-3\n",
    "model.fit(train_transformed, validation_data=valid_transformed, batch_size=1024, epochs=3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1af903a8",
   "metadata": {},
   "source": [
    "Let us now retry the training without the `genres` information. Maybe we have reason to suspect this data has some issues and we would like to verify how the model performs without this information being passed in.\n",
    "\n",
    "We can achieve all this by modifying the passed in schema using the `without` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "3e8132d1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/5\n",
      "782/782 [==============================] - 10s 11ms/step - loss: 0.5666 - precision_1: 0.7193 - recall_1: 0.8067 - binary_accuracy: 0.7078 - auc_1: 0.7668 - regularization_loss: 0.0000e+00 - val_loss: 0.5415 - val_precision_1: 0.7386 - val_recall_1: 0.8128 - val_binary_accuracy: 0.7268 - val_auc_1: 0.7936 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 2/5\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.5451 - precision_1: 0.7343 - recall_1: 0.8115 - binary_accuracy: 0.7227 - auc_1: 0.7880 - regularization_loss: 0.0000e+00 - val_loss: 0.5314 - val_precision_1: 0.7508 - val_recall_1: 0.7996 - val_binary_accuracy: 0.7320 - val_auc_1: 0.8009 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 3/5\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.5374 - precision_1: 0.7398 - recall_1: 0.8116 - binary_accuracy: 0.7274 - auc_1: 0.7949 - regularization_loss: 0.0000e+00 - val_loss: 0.5239 - val_precision_1: 0.7529 - val_recall_1: 0.8055 - val_binary_accuracy: 0.7361 - val_auc_1: 0.8070 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 4/5\n",
      "782/782 [==============================] - 8s 9ms/step - loss: 0.5307 - precision_1: 0.7423 - recall_1: 0.8171 - binary_accuracy: 0.7316 - auc_1: 0.8007 - regularization_loss: 0.0000e+00 - val_loss: 0.5171 - val_precision_1: 0.7567 - val_recall_1: 0.8113 - val_binary_accuracy: 0.7415 - val_auc_1: 0.8134 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 5/5\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.5233 - precision_1: 0.7476 - recall_1: 0.8185 - binary_accuracy: 0.7366 - auc_1: 0.8073 - regularization_loss: 0.0000e+00 - val_loss: 0.5092 - val_precision_1: 0.7577 - val_recall_1: 0.8232 - val_binary_accuracy: 0.7468 - val_auc_1: 0.8196 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 1/3\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.5038 - precision_1: 0.7594 - recall_1: 0.8249 - binary_accuracy: 0.7489 - auc_1: 0.8235 - regularization_loss: 0.0000e+00 - val_loss: 0.4938 - val_precision_1: 0.7656 - val_recall_1: 0.8327 - val_binary_accuracy: 0.7571 - val_auc_1: 0.8316 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 2/3\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.4953 - precision_1: 0.7637 - recall_1: 0.8316 - binary_accuracy: 0.7551 - auc_1: 0.8303 - regularization_loss: 0.0000e+00 - val_loss: 0.4856 - val_precision_1: 0.7670 - val_recall_1: 0.8440 - val_binary_accuracy: 0.7628 - val_auc_1: 0.8381 - val_regularization_loss: 0.0000e+00\n",
      "Epoch 3/3\n",
      "782/782 [==============================] - 8s 10ms/step - loss: 0.4881 - precision_1: 0.7674 - recall_1: 0.8360 - binary_accuracy: 0.7599 - auc_1: 0.8360 - regularization_loss: 0.0000e+00 - val_loss: 0.4781 - val_precision_1: 0.7727 - val_recall_1: 0.8451 - val_binary_accuracy: 0.7679 - val_auc_1: 0.8437 - val_regularization_loss: 0.0000e+00\n"
     ]
    }
   ],
   "source": [
    "import tensorflow\n",
    "import merlin.models.tf as mm\n",
    "\n",
    "model = mm.DLRMModel(\n",
    "    train_transformed.schema.without('genres'),   # <--- this is where we make the change\n",
    "    embedding_dim=64,\n",
    "    bottom_block=mm.MLPBlock([128, 64]),\n",
    "    top_block=mm.MLPBlock([128, 64, 32]),\n",
    "    prediction_tasks=mm.BinaryClassificationTask('rating_binary')\n",
    ")\n",
    "\n",
    "opt = tensorflow.optimizers.Adam(learning_rate=5e-3)\n",
    "model.compile(optimizer=opt)\n",
    "model.fit(train_transformed, validation_data=valid_transformed, batch_size=1024, epochs=5)\n",
    "\n",
    "model.optimizer.learning_rate = 1e-3\n",
    "metrics = model.fit(train_transformed, validation_data=valid_transformed, batch_size=1024, epochs=3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05c9f35b",
   "metadata": {},
   "source": [
    "As it turns out, `genres` contained signal that was genuinely useful to the model as without it the performance on the validation set decreased!\n",
    "\n",
    "Using the `Schema` (combined with the ability of the Merlin Framework to infer the appropriate shape of the model based on our data) we can streamline the training and experimentation phase to a significant extent."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a999265",
   "metadata": {},
   "source": [
    "## Next steps"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c89f0cca",
   "metadata": {},
   "source": [
    "We are using NVTabular in our Merlin repositories to preprocess and engineer features before training. We can recommend multiple examples, which show complex pipelines with NVTabular:\n",
    "\n",
    "* [This notebook](https://github.com/NVIDIA-Merlin/models/blob/main/examples/usecases/ecommerce-session-based-next-item-prediction-for-fashion.ipynb) demonstrates how to aggregate data -- we are going from multiple rows of session information to a single row describing a session.\n",
    "\n",
    "* The [following notebook](https://github.com/NVIDIA-Merlin/Transformers4Rec/blob/main/examples/end-to-end-session-based/01-ETL-with-NVTabular.ipynb) demonstrates how to derive features from timestamps and how to define a custom operator (`ItemRecency`).\n",
    "\n",
    "- In [this notebook](https://github.com/NVIDIA-Merlin/publications/blob/main/tutorials/RecSys22tutorial/02-Implementing-RecSys-architectures.ipynb), among other functionality, you can familiarize yourself with using `TargetEncoding`, filling missing values, `Normalization` as well as adding various `MetaData`. Do note, this notebook is not maintained and thus there might be discrepancies between it and the most up to date version of NVTabular."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  },
  "merlin": {
   "containers": [
    "nvcr.io/nvidia/merlin/merlin-tensorflow:latest"
   ]
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
