{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2021 NVIDIA Corporation. All Rights Reserved.\n",
    "#\n",
    "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
    "# you may not use this file except in compliance with the License.\n",
    "# You may obtain a copy of the License at\n",
    "#\n",
    "#     http://www.apache.org/licenses/LICENSE-2.0\n",
    "#\n",
    "# Unless required by applicable law or agreed to in writing, software\n",
    "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
    "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
    "# See the License for the specific language governing permissions and\n",
    "# limitations under the License.\n",
    "# =============================================================================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Scaling Criteo: Triton Inference with TensorFlow\n",
    "\n",
    "## Overview\n",
    "\n",
    "The last step is to deploy the ETL workflow and saved model to production. In the production setting, we want to transform the input data as during training (ETL). We need to apply the same mean/std for continuous features and use the same categorical mapping to convert the categories to continuous integer before we use the deep learning model for a prediction. Therefore, we deploy the NVTabular workflow with the TensorFlow model as an ensemble model to Triton Inference. The ensemble model garantuees that the same transformation are applied to the raw inputs.\n",
    "\n",
    "<img src='./imgs/triton-tf.png' width=\"25%\">\n",
    "\n",
    "### Learning objectives\n",
    "\n",
    "In this notebook, we learn how to deploy our models to production\n",
    "\n",
    "- Use **NVTabular** to generate config and model files for Triton Inference Server\n",
    "- Deploy an ensemble of NVTabular workflow and TensorFlow model\n",
    "- Send example request to Triton Inference Server"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inference with Triton and TensorFlow\n",
    "\n",
    "First, we need to generate the Triton Inference Server configurations and save the models in the correct format. In the previous notebooks [02-ETL-with-NVTabular](./02-ETL-with-NVTabular.ipynb) and [03-Training-with-TF](./03-Training-with-TF.ipynb) we saved the NVTabular workflow and TensorFlow model to disk. We will load them."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Saving Ensemble Model for Triton Inference Server"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "import tensorflow as tf\n",
    "import nvtabular as nvt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "BASE_DIR = os.environ.get(\"BASE_DIR\", \"/raid/data/criteo\")\n",
    "input_path = os.environ.get(\"INPUT_DATA_DIR\", os.path.join(BASE_DIR, \"test_dask/output\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "workflow = nvt.Workflow.load(os.path.join(input_path, \"workflow\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = tf.keras.models.load_model(os.path.join(input_path, \"model.savedmodel\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow expect the Integer as `int32` datatype. Therefore, we need to define the NVTabular output datatypes to `int32` for categorical features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for key in workflow.output_dtypes.keys():\n",
    "    if key.startswith(\"C\"):\n",
    "        workflow.output_dtypes[key] = \"int32\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "NVTabular provides an easy function to deploy the ensemble model for Triton Inference Server."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from nvtabular.inference.triton import export_tensorflow_ensemble"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "export_tensorflow_ensemble(model, workflow, \"criteo\", \"/tmp/model/models/\", [\"label\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can take a look on the generated files."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# !tree /model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Loading Ensemble Model with Triton Inference Server\n",
    "\n",
    "We have only saved the models for Triton Inference Server. We started Triton Inference Server in explicit mode, meaning that we need to send a request that Triton will load the ensemble model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, we restart this notebook to free the GPU memory."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# import IPython\n",
    "\n",
    "# app = IPython.Application.instance()\n",
    "# app.kernel.do_shutdown(True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We define the BASE_DIR again."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "BASE_DIR = os.environ.get(\"BASE_DIR\", \"/raid/data/criteo\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We connect to the Triton Inference Server."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "client created.\n"
     ]
    }
   ],
   "source": [
    "import tritonclient.grpc as grpc_client\n",
    "\n",
    "try:\n",
    "    triton_client = grpc_client.InferenceServerClient(url=\"localhost:8001\", verbose=True)\n",
    "    print(\"client created.\")\n",
    "except Exception as e:\n",
    "    print(\"channel creation failed: \" + str(e))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We deactivate warnings."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We check if the server is alive."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "is_server_live, metadata ()\n",
      "\n",
      "live: true\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "triton_client.is_server_live()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We check the available models in the repositories:\n",
    "- criteo: Ensemble \n",
    "- criteo_nvt: NVTabular \n",
    "- criteo_tf: TensorFlow model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "get_model_repository_index, metadata ()\n",
      "\n",
      "models {\n",
      "  name: \"criteo\"\n",
      "}\n",
      "models {\n",
      "  name: \"criteo_nvt\"\n",
      "}\n",
      "models {\n",
      "  name: \"criteo_tf\"\n",
      "}\n",
      "models {\n",
      "  name: \"movielens\"\n",
      "}\n",
      "models {\n",
      "  name: \"movielens_nvt\"\n",
      "}\n",
      "models {\n",
      "  name: \"movielens_tf\"\n",
      "}\n",
      "models {\n",
      "  name: \"rossmann\"\n",
      "}\n",
      "models {\n",
      "  name: \"rossmann_nvt\"\n",
      "}\n",
      "models {\n",
      "  name: \"rossmann_tf\"\n",
      "}\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "models {\n",
       "  name: \"criteo\"\n",
       "}\n",
       "models {\n",
       "  name: \"criteo_nvt\"\n",
       "}\n",
       "models {\n",
       "  name: \"criteo_tf\"\n",
       "}\n",
       "models {\n",
       "  name: \"movielens\"\n",
       "}\n",
       "models {\n",
       "  name: \"movielens_nvt\"\n",
       "}\n",
       "models {\n",
       "  name: \"movielens_tf\"\n",
       "}\n",
       "models {\n",
       "  name: \"rossmann\"\n",
       "}\n",
       "models {\n",
       "  name: \"rossmann_nvt\"\n",
       "}\n",
       "models {\n",
       "  name: \"rossmann_tf\"\n",
       "}"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "triton_client.get_model_repository_index()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We load the ensembled model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "load_model, metadata ()\n",
      "model_name: \"criteo\"\n",
      "\n"
     ]
    },
    {
     "ename": "InferenceServerException",
     "evalue": "[StatusCode.UNAVAILABLE] explicit model load / unload is not allowed if polling is enabled",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mInferenceServerException\u001b[0m                  Traceback (most recent call last)",
      "File \u001b[0;32m<timed eval>:1\u001b[0m, in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n",
      "File \u001b[0;32m/usr/local/lib/python3.8/dist-packages/tritonclient/grpc/__init__.py:646\u001b[0m, in \u001b[0;36mInferenceServerClient.load_model\u001b[0;34m(self, model_name, headers, config)\u001b[0m\n\u001b[1;32m    644\u001b[0m         \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mLoaded model \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m.\u001b[39mformat(model_name))\n\u001b[1;32m    645\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m grpc\u001b[38;5;241m.\u001b[39mRpcError \u001b[38;5;28;01mas\u001b[39;00m rpc_error:\n\u001b[0;32m--> 646\u001b[0m     \u001b[43mraise_error_grpc\u001b[49m\u001b[43m(\u001b[49m\u001b[43mrpc_error\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[0;32m/usr/local/lib/python3.8/dist-packages/tritonclient/grpc/__init__.py:62\u001b[0m, in \u001b[0;36mraise_error_grpc\u001b[0;34m(rpc_error)\u001b[0m\n\u001b[1;32m     61\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mraise_error_grpc\u001b[39m(rpc_error):\n\u001b[0;32m---> 62\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m get_error_grpc(rpc_error) \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;28mNone\u001b[39m\n",
      "\u001b[0;31mInferenceServerException\u001b[0m: [StatusCode.UNAVAILABLE] explicit model load / unload is not allowed if polling is enabled"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "triton_client.load_model(model_name=\"criteo\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Example Request to Triton Inference Server\n",
    "\n",
    "Now, the models are loaded and we can create a sample request. We read an example **raw batch** for inference."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "     I1   I2    I3    I4    I5  I6  I7  I8  I9  I10  ...        C17  \\\n",
      "0     5  110  <NA>    16  <NA>   1   0  14   7    1  ... -771205462   \n",
      "1    32    3     5  <NA>     1   0   0  61   5    0  ... -771205462   \n",
      "2  <NA>  233     1   146     1   0   0  99   7    0  ... -771205462   \n",
      "\n",
      "          C18         C19         C20         C21        C22        C23  \\\n",
      "0 -1206449222 -1793932789 -1014091992   351689309  632402057 -675152885   \n",
      "1 -1578429167 -1793932789   -20981661 -1556988767 -924717482  391309800   \n",
      "2  1653545869 -1793932789 -1014091992   351689309  632402057 -675152885   \n",
      "\n",
      "          C24         C25         C26  \n",
      "0  2091868316   809724924  -317696227  \n",
      "1  1966410890 -1726799382 -1218975401  \n",
      "2   883538181   -10139646  -317696227  \n",
      "\n",
      "[3 rows x 39 columns]\n"
     ]
    }
   ],
   "source": [
    "# Get dataframe library - cudf or pandas\n",
    "from merlin.core.dispatch import get_lib\n",
    "\n",
    "df_lib = get_lib()\n",
    "\n",
    "# read in the workflow (to get input/output schema to call triton with)\n",
    "batch_path = os.path.join(BASE_DIR, \"converted/criteo\")\n",
    "# raise(ValueError(f\"{batch_path}\"))\n",
    "batch = df_lib.read_parquet(os.path.join(batch_path, \"*.parquet\"), num_rows=3)\n",
    "batch = batch[[x for x in batch.columns if x != \"label\"]]\n",
    "print(batch)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We prepare the batch for inference by using correct column names and data types. We use the same datatypes as defined in our dataframe."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "I1     int32\n",
       "I2     int32\n",
       "I3     int32\n",
       "I4     int32\n",
       "I5     int32\n",
       "I6     int32\n",
       "I7     int32\n",
       "I8     int32\n",
       "I9     int32\n",
       "I10    int32\n",
       "I11    int32\n",
       "I12    int32\n",
       "I13    int32\n",
       "C1     int32\n",
       "C2     int32\n",
       "C3     int32\n",
       "C4     int32\n",
       "C5     int32\n",
       "C6     int32\n",
       "C7     int32\n",
       "C8     int32\n",
       "C9     int32\n",
       "C10    int32\n",
       "C11    int32\n",
       "C12    int32\n",
       "C13    int32\n",
       "C14    int32\n",
       "C15    int32\n",
       "C16    int32\n",
       "C17    int32\n",
       "C18    int32\n",
       "C19    int32\n",
       "C20    int32\n",
       "C21    int32\n",
       "C22    int32\n",
       "C23    int32\n",
       "C24    int32\n",
       "C25    int32\n",
       "C26    int32\n",
       "dtype: object"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch.dtypes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tritonclient.grpc as httpclient\n",
    "from tritonclient.utils import np_to_triton_dtype\n",
    "import numpy as np\n",
    "\n",
    "inputs = []\n",
    "\n",
    "col_names = list(batch.columns)\n",
    "col_dtypes = [np.int32] * len(col_names)\n",
    "\n",
    "for i, col in enumerate(batch.columns):\n",
    "    d = batch[col].fillna(0).values_host.astype(col_dtypes[i])\n",
    "    d = d.reshape(len(d), 1)\n",
    "    inputs.append(httpclient.InferInput(col_names[i], d.shape, np_to_triton_dtype(col_dtypes[i])))\n",
    "    inputs[i].set_data_from_numpy(d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We send the request to the triton server and collect the last output."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "infer, metadata ()\n",
      "model_name: \"criteo\"\n",
      "id: \"1\"\n",
      "inputs {\n",
      "  name: \"I1\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I2\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I3\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I4\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I5\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I6\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I7\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I8\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I9\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I10\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I11\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I12\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"I13\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C1\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C2\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C3\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C4\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C5\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C6\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C7\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C8\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C9\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C10\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C11\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C12\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C13\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C14\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C15\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C16\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C17\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C18\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C19\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C20\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C21\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C22\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C23\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C24\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C25\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "inputs {\n",
      "  name: \"C26\"\n",
      "  datatype: \"INT32\"\n",
      "  shape: 3\n",
      "  shape: 1\n",
      "}\n",
      "outputs {\n",
      "  name: \"output\"\n",
      "}\n",
      "raw_input_contents: \"\\005\\000\\000\\000 \\000\\000\\000\\000\\000\\000\\000\"\n",
      "raw_input_contents: \"n\\000\\000\\000\\003\\000\\000\\000\\351\\000\\000\\000\"\n",
      "raw_input_contents: \"\\000\\000\\000\\000\\005\\000\\000\\000\\001\\000\\000\\000\"\n",
      "raw_input_contents: \"\\020\\000\\000\\000\\000\\000\\000\\000\\222\\000\\000\\000\"\n",
      "raw_input_contents: \"\\000\\000\\000\\000\\001\\000\\000\\000\\001\\000\\000\\000\"\n",
      "raw_input_contents: \"\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n",
      "raw_input_contents: \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n",
      "raw_input_contents: \"\\016\\000\\000\\000=\\000\\000\\000c\\000\\000\\000\"\n",
      "raw_input_contents: \"\\007\\000\\000\\000\\005\\000\\000\\000\\007\\000\\000\\000\"\n",
      "raw_input_contents: \"\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n",
      "raw_input_contents: \"\\000\\000\\000\\000\\001\\000\\000\\000\\001\\000\\000\\000\"\n",
      "raw_input_contents: \"2\\001\\000\\000U\\014\\000\\000\\035\\014\\000\\000\"\n",
      "raw_input_contents: \"\\000\\000\\000\\000\\005\\000\\000\\000\\001\\000\\000\\000\"\n",
      "raw_input_contents: \"y\\rwb\\215\\375\\363\\345y\\rwb\"\n",
      "raw_input_contents: \"X]\\037\\342\\246\\377\\252\\240\\003B\\230\\255\"\n",
      "raw_input_contents: \"/D\\352\\257\\325\\025\\252o\\r\\306\\276b\"\n",
      "raw_input_contents: \"\\317\\177\\\\\\224!4\\212\\332\\356Il8\"\n",
      "raw_input_contents: \"H\\'\\2608#\\237\\326<M\\006U\\347\"\n",
      "raw_input_contents: \"\\313m\\315o\\313m\\315o\\313m\\315o\"\n",
      "raw_input_contents: \"!\\252\\2005\\201\\355\\026\\253b\\353\\365\\265\"\n",
      "raw_input_contents: \"\\003\\211\\200()lBC\\213\\314\\362\\321\"\n",
      "raw_input_contents: \"\\246\\337\\336FT\\341\\365\\035\\037\\202N.\"\n",
      "raw_input_contents: \"\\301}\\002.\\251\\300\\351}\\301}\\002.\"\n",
      "raw_input_contents: \"1B|\\014d\\334Rf1B|\\014\"\n",
      "raw_input_contents: \"\\037\\035\\230\\225\\'N\\353\\231\\204aq\\022\"\n",
      "raw_input_contents: \"\\267\\377\\305\\000\\267\\377\\305\\000\\267\\377\\305\\000\"\n",
      "raw_input_contents: \"7\\345N\\2767\\345N\\2767\\345N\\276\"\n",
      "raw_input_contents: \"\\314t\\013\\212\\231\\376\\273\\363\\013\\r\\017\\367\"\n",
      "raw_input_contents: \"\\372>\\334L\\372>\\334L\\372>\\334L\"\n",
      "raw_input_contents: \"\\252V\\010\\322\\252V\\010\\322\\252V\\010\\322\"\n",
      "raw_input_contents: \"\\272\\013\\027\\270\\021\\025\\353\\241\\215\\033\\217b\"\n",
      "raw_input_contents: \"\\013\\302\\022\\225\\013\\302\\022\\225\\013\\302\\022\\225\"\n",
      "raw_input_contents: \"(/\\216\\303c\\330\\277\\376(/\\216\\303\"\n",
      "raw_input_contents: \"]Z\\366\\024\\241<2\\243]Z\\366\\024\"\n",
      "raw_input_contents: \"\\211\\260\\261%V\\356\\341\\310\\211\\260\\261%\"\n",
      "raw_input_contents: \"\\013\\374\\301\\327\\350\\351R\\027\\013\\374\\301\\327\"\n",
      "raw_input_contents: \"\\234`\\257|\\212\\0145u\\005\\271\\2514\"\n",
      "raw_input_contents: \"\\374kC0\\352!\\023\\231\\002He\\377\"\n",
      "raw_input_contents: \"\\035W\\020\\355W\\351W\\267\\035W\\020\\355\"\n",
      "\n"
     ]
    },
    {
     "ename": "InferenceServerException",
     "evalue": "[StatusCode.UNAVAILABLE] Request for unknown model: 'criteo' is not found",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mInferenceServerException\u001b[0m                  Traceback (most recent call last)",
      "Input \u001b[0;32mIn [11]\u001b[0m, in \u001b[0;36m<cell line: 7>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m outputs \u001b[38;5;241m=\u001b[39m [httpclient\u001b[38;5;241m.\u001b[39mInferRequestedOutput(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124moutput\u001b[39m\u001b[38;5;124m\"\u001b[39m)]\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# build a client to connect to our server.\u001b[39;00m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;66;03m# This InferenceServerClient object is what we'll be using to talk to Triton.\u001b[39;00m\n\u001b[1;32m      6\u001b[0m \u001b[38;5;66;03m# make the request with tritonclient.http.InferInput object\u001b[39;00m\n\u001b[0;32m----> 7\u001b[0m response \u001b[38;5;241m=\u001b[39m \u001b[43mtriton_client\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43minfer\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mcriteo\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43minputs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mrequest_id\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m1\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43moutputs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43moutputs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mpredicted softmax result:\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m\"\u001b[39m, response\u001b[38;5;241m.\u001b[39mas_numpy(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124moutput\u001b[39m\u001b[38;5;124m\"\u001b[39m))\n",
      "File \u001b[0;32m/usr/local/lib/python3.8/dist-packages/tritonclient/grpc/__init__.py:1295\u001b[0m, in \u001b[0;36mInferenceServerClient.infer\u001b[0;34m(self, model_name, inputs, model_version, outputs, request_id, sequence_id, sequence_start, sequence_end, priority, timeout, client_timeout, headers, compression_algorithm)\u001b[0m\n\u001b[1;32m   1293\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m result\n\u001b[1;32m   1294\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m grpc\u001b[38;5;241m.\u001b[39mRpcError \u001b[38;5;28;01mas\u001b[39;00m rpc_error:\n\u001b[0;32m-> 1295\u001b[0m     \u001b[43mraise_error_grpc\u001b[49m\u001b[43m(\u001b[49m\u001b[43mrpc_error\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[0;32m/usr/local/lib/python3.8/dist-packages/tritonclient/grpc/__init__.py:62\u001b[0m, in \u001b[0;36mraise_error_grpc\u001b[0;34m(rpc_error)\u001b[0m\n\u001b[1;32m     61\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mraise_error_grpc\u001b[39m(rpc_error):\n\u001b[0;32m---> 62\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m get_error_grpc(rpc_error) \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;28mNone\u001b[39m\n",
      "\u001b[0;31mInferenceServerException\u001b[0m: [StatusCode.UNAVAILABLE] Request for unknown model: 'criteo' is not found"
     ]
    }
   ],
   "source": [
    "# placeholder variables for the output\n",
    "outputs = [httpclient.InferRequestedOutput(\"output\")]\n",
    "\n",
    "# build a client to connect to our server.\n",
    "# This InferenceServerClient object is what we'll be using to talk to Triton.\n",
    "# make the request with tritonclient.http.InferInput object\n",
    "response = triton_client.infer(\"criteo\", inputs, request_id=\"1\", outputs=outputs)\n",
    "\n",
    "print(\"predicted softmax result:\\n\", response.as_numpy(\"output\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's unload the model. We need to unload each model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "triton_client.unload_model(model_name=\"criteo\")\n",
    "triton_client.unload_model(model_name=\"criteo_nvt\")\n",
    "triton_client.unload_model(model_name=\"criteo_tf\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
